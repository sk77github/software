一定要有备份，备份数据和binlog以及其他文件，保证备份可用，可以还原出某个时间点的数据库状态，
包括数据库数据，配置文件，binlog等所有。定期做还原演练。要有从库，或者有延迟复制的从库。

标准化：
线上实例，要有规范，统一管理。
各种目录规范，权限规范，帐号规范（管理账号，复制帐号，程序帐号，只读帐号），安装规范（结合目录规范），
mysql版本一致，配置文件一致，机器硬件配置灵活斟酌一致。
机器域名规范（约定好于配置，看机器域名就能知道机器的细节，比如上线时间，是哪个业务的主库还是从库，存储的是那个sharding分片）
建表规范（表名，字段名要能自说明）


有各种监控，报警
监控项：
mysqld活着，3306端口可用
磁盘有空间
复制不延迟，复制IO thread 和 SQL thread 都是yes
做table checksum 确保主从数据一致（可使用pt-table-checksum）
监控读写比（COM_SELECT,那四个）
监控QPS（也是COM_SELECT那四个）
监控TPS
监控IOPS
控制recovery还原时间
mysql连接数


流程化：
线上操作规范与流程：

delete数据之前最好先select一下，select review这些数据确实是自己需要删除的数据，之后再备份一下，然后就可以删除了。
把删除操作做成一个工具，工具来强制备份（mysql inception这个开源工具有此功能吗）


自动化：
自动化安装
自动化HA切换
自动化上下线
自动化建库建表加索引SQL审核
自动化复制搭建






最佳实践：

理念：
尽量将mysql想象成是可以持久化的基于主键的key-value存储。尽量做单表查询
做好容量规划，控制单表行数，单表数据量，合理按uid,时间，地区等纬度散表
平衡范式与泛范式，合理设计表结构和索引，表有主键
不在数据库做运算，数据库是为了实现事务的，是为了持久化的，是为了把持久化的东西查出来的
不用大SQL，大事务。小事务减少资源的锁定占用，提高并发，降低死锁的概率
平衡单表多次小sql简单查询与一次关联查询，大多数情况下，前者好（且方便分表）。
大sql可能会跑满CPU，长时间占用CPU，把其他查询堵死。小sql缓存命中率高，CPU切换快


容量规划：
控制单表数据量，做容量规划，有表数据量监控图，表的行数，表的大小（可用系统表信息打入graphite实现）
合理按uid，时间，地区等纬度拆表，具体多大的表合适，参照各种监控指标（监控指标带罗列）

建表相关：
表要建主键，忌用字符串做主键。推荐用独立于业务的自增id（或全局id生成器）做主键。
主键独立于业务，与业务无关，还会方便修数据(比如主从复制主键冲突，从库有数据，但主库没有时）
线上oltp系统尽量不用外键，由程序保证约束完整性
避免使用null字段。（建表语句要是 not null default ‘’ comment '' 类似这样）
少用text/blob这样的大字段，并且要将这样的大字段拆分。
合理的范式和反范式
统一命名规范，库表等名称统一用小写，约定大于配置，索引命名默认为"idx_字段名"

sql相关：
不在数据库做运算，数据库是为了实现事务的，是为了持久化的，是为了把持久化的东西查出来的
复杂运算移到程序端CPU，不在数据库做md5(),order by rand()这些
不用大SQL，大事务。尽量将mysql想象成是可以持久化的基于主键的key-value存储。尽量做单表查询，
平衡单表多次小sql简单查询与一次关联查询，大多数情况下，前者好（且方便分表）。
大sql可能会跑满CPU，长时间占用CPU，把其他查询堵死。小sql缓存命中率高，CPU切换快
不用select *，增加网络开销，增加IO，增加CPU开销，使用不上索引覆盖，只取需要的列
相同字段or查询改为in，不同字段or查询改为union（这取决于mysql优化器，目前是这样的）
知道数据库里都有哪些sql运行，知道他们的行为，show profile，show processlist，explain，slowlog等监控项

使用相关：
尽量不做批量操作，批量操作DBA来评估，批量操作可换成几段的操作，并有sleep机制，并结合监控图看操作影响。
线上oltp，尽量不用存储过程，触发器，函数
用load data导数据，无索引时比有索引快很多（可先将索引删掉，导完在建），insert多个value，减少索引刷新
load data比insert快很多
尽量不用insert---select这样的复合语句，会促发GTID，事务及锁等行为的改变
隔离线上线下，构建数据库的生态环境，开发无线上库操作权限，原则：线上连线上，线下连线下
实时数据用实时库
模拟环境用模拟库
测试用qa库
开发用dev库
禁止未经DBA确认的子查询，MySQL子查询大部分情况优化较差，一般可用join改写
举例：
MySQL> select * from table 1 where id in(select id from table2);
MySQL> insert into table1 (select * from table2); //可能导致复制异常
统一字符集为UTF8，utf8m64，统一存储，校对规则（utf8_general_ci），客户端，程序，前端的字符编码
乱码：set names utf8


事务相关：
保持事务短小，事务即开即用，用完即关，与事务无关操作放在事务外面，不破坏一致性前提下，使用多个小事务代替大事务。
这样做的目的是，减少资源的锁定占用，提高并发，降低死锁的概率


索引相关：
谨慎根据表的读写比，索引区分度，sql影响到的行数合理添加索引
尽量可以走索引覆盖
字符字段建前缀索引(6个字母的前缀索引就3亿的区分度了）
使查询走索引，不要在sql的索引列上做运算，不要在索引列上应用函数，尽量使索引列“干净，单独”的存在。
与索引比较的值，要是确定性的，不确定的用不是索引，比如like “%”
同数据类型列值相比较，否则容易促发用不上索引

