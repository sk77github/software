一致性非锁定读，也叫快照读：（MVCC实现，而MVCC基于undo log）
当session A读取的行正在session B事务内执行DELETE、UPDATE操作时（此时session B 对数据行加了X锁），这时session A的读取操作不会因此等待行上
的锁释放。相反，它会去读取一个数据快照。（而在RR隔离级别下，session B提交了事务，释放了锁后，session A读取的仍是 session A事务开始时的
数据版本。而在RC隔离级别下，sessionB提交了事务，释放了锁后，session A读取的是数据最新版本，是被session B修改后的版本。此时对于session A
来说，是不可重复读）现在相信大家已经理解了我们为什么将它称之为非锁定读，因为不需要等待访问行上X锁的释放。

             Session A              Session B

           SET autocommit=0;      SET autocommit=0;
time
|          SELECT * FROM t;
|          empty set
|                                 INSERT INTO t VALUES (1, 2);
|
v          SELECT * FROM t;
           empty set
                                  COMMIT;

           SELECT * FROM t;
           empty set

           COMMIT;

           SELECT * FROM t;
           ---------------------
           |    1    |    2    |
           ---------------------


innodb在默认情况下的读采取的是一致性非锁定读，但在某些情况下，innodb不采用这种方法。
比如，你在显式对读进行加锁情况下（当前读）
select * from table where ? lock in share mode;(sets an IS lock)
select * from table where ? for update;(sets an IX lock)
或者在外键的插入和更新上，因为在外键的插入更新上，对于数据的隔离性要求较高，在插入前需要扫描父表中的记录是否存在，
所以，innodb在外键添加删除这种操作上，会采用加S锁的这种方式来实现。

rc事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据.（因为read commited嘛，但不可重复读）
RR事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。

快照读只适用于SELECT语句，不适用与DML语句，所以事务中的DML语句（当前读）是可以看到其他session中的事务的更新的，即时SELECT并不能看到这些


快照读：就是select
select * from table ....;
当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。
select * from table where ? lock in share mode;(sets an IS lock)
select * from table where ? for update;(sets an IX lock)
insert;
update ? where ?;
delete ? where ?;
事务的隔离级别实际上都是定义了当前读的级别

--------------------------------------------------------------------------------------------------------------




所谓innodb行锁，是针对有索引的语句，如果语句没有使用上索引，那么就会变成无索引退化，对于当前读就会变成表锁。




对于当前读：
序列化
幻读（如果只有幻读，那么就已经可重复读）
可重复读
不可重复读
脏读






事务，事务的隔离级别涉及锁，事务的实现方式MVCC与两阶段锁

autocommit = 1，使每一个语句都成为一个事务。If a statement returns an error, the commit or rollback behavior depends on the error：
http://dev.mysql.com/doc/refman/5.6/en/innodb-transaction-model.html
autocommit = 0, commit或者rollback后，会自动又开启一个事务，就是说当前session始终有事务打开

自动提交情况下，如果想用多条语句事务，可以使用 start transaction 或者 begin 结束时或者commit或者rollback。
commit和rollback会释放当前session持有的所有锁



事务隔离级别（要从当前事务和其他事务两个角度考虑，而且要有时序图与锁的想象，因为隔离级别通过锁实现）：

SERIALIZABLE        从MVCC退化为基于锁的并发控制。无快照读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。读写互斥。
READ UNCOMMITTED    可读未提交，会脏读，不可重复读，会幻读
READ COMMITTED      未提交不可读，只能读已提交。不会脏读，不可重复读，会幻读
REPEATABLE READ     可重复读，需要用next-key解决幻读






锁：
record lock
gap lock
next key lock
行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别的幻读问题。

共享锁  也叫S锁  也叫读锁
排他锁  也叫X锁  也叫写锁
意向锁  包括IS锁与IX锁













mysql index condition pushdow


MySQL Fabric



GTID

