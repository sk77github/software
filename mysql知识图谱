一致性非锁定读，也叫快照读：（MVCC实现，而MVCC基于undo log）
当session A读取的行正在session B事务内执行DELETE、UPDATE操作时（此时session B 对数据行加了X锁），这时session A的读取操作不会因此等待行上
的锁释放。相反，它会去读取一个数据快照。（而在RR隔离级别下，session B提交了事务，释放了锁后，session A读取的仍是 session A事务开始时的
数据版本。而在RC隔离级别下，sessionB提交了事务，释放了锁后，session A读取的是数据最新版本，是被session B修改后的版本。此时对于session A
来说，是不可重复读）现在相信大家已经理解了我们为什么将它称之为非锁定读，因为不需要等待访问行上X锁的释放。

             Session A              Session B

           SET autocommit=0;      SET autocommit=0;
time
|          SELECT * FROM t;
|          empty set
|                                 INSERT INTO t VALUES (1, 2);
|
v          SELECT * FROM t;
           empty set
                                  COMMIT;

           SELECT * FROM t;
           empty set

           COMMIT;

           SELECT * FROM t;
           ---------------------
           |    1    |    2    |
           ---------------------


innodb在默认情况下的读采取的是一致性非锁定读，但在某些情况下，innodb不采用这种方法。
比如，你在显式对读进行加锁情况下（当前读）
select * from table where ? lock in share mode;(sets an IS lock)
select * from table where ? for update;(sets an IX lock)
或者在外键的插入和更新上，因为在外键的插入更新上，对于数据的隔离性要求较高，在插入前需要扫描父表中的记录是否存在，
所以，innodb在外键添加删除这种操作上，会采用加S锁的这种方式来实现。

rc事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据.（因为read commited嘛，但不可重复读）
RR事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。

快照读只适用于SELECT语句，不适用与DML语句，所以事务中的DML语句（当前读）是可以看到其他session中的事务的更新的，即时SELECT并不能看到这些


快照读：就是select
select * from table ....;
当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。
select * from table where ? lock in share mode;(sets an IS lock)
select * from table where ? for update;(sets an IX lock)
insert;
update ? where ?;
delete ? where ?;
事务的隔离级别实际上都是定义了当前读的级别

--------------------------------------------------------------------------------------------------------------
事务和锁

所谓innodb行锁，是针对有索引的语句，如果语句没有使用上索引，那么就会变成无索引退化，对于当前读就会变成表锁。


对于当前读：
序列化
幻读（如果只有幻读，那么就已经可重复读）
可重复读
不可重复读
脏读


autocommit = 1，使每一个语句都成为一个事务。If a statement returns an error, the commit or rollback behavior depends on the error：
http://dev.mysql.com/doc/refman/5.6/en/innodb-transaction-model.html
autocommit = 0, commit或者rollback后，会自动又开启一个事务，就是说当前session始终有事务打开

自动提交情况下，如果想用多条语句事务，可以使用 start transaction 或者 begin 结束时或者commit或者rollback。
commit和rollback会释放当前session持有的所有锁



事务隔离级别（要从当前事务和其他事务两个角度考虑，而且要有时序图与锁的想象，因为隔离级别通过锁实现）：

SERIALIZABLE        从MVCC退化为基于锁的并发控制。无快照读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。读写互斥。
READ UNCOMMITTED    可读未提交，会脏读，不可重复读，会幻读
READ COMMITTED      未提交不可读，只能读已提交。不会脏读，不可重复读，会幻读
REPEATABLE READ     可重复读，需要用next-key解决幻读
                    REPEATABLE READ, enables higher concurrency by allowing transactions to read rows that have exclusive locks,
                    a technique known as consistent nonlocking read.






锁：
record lock
gap lock
next key lock
行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别的幻读问题。

共享锁  也叫S锁  也叫读锁
排他锁  也叫X锁  也叫写锁
意向锁  包括IS锁与IX锁


    	 X          IX	         S      	   IS
X	  Conflict	Conflict	  Conflict	  Conflict
IX	Conflict	Compatible	Conflict	  Compatible
S	  Conflict	Conflict	  Compatible	Compatible
IS	Conflict	Compatible	Compatible	Compatible


-------------------------------------------------------------------------------------------------------
加锁语句：
因为事务一旦完成（commit或者rollback），事务所持有的锁就会释放。
故在autocommit = 1 时，需要注意

select * from table where ? lock in share mode;(sets an IS lock)
select * from table where ? for update;(sets an IX lock)
当autocommit 系统变量值为off 或者为0 时可直接使用不用手动的begin or start transaction开启事务，
如果autocommit为1，需要begin或者start transaction 在使用上述两个语句加锁（因为如果为1，自动提交，事务就结束了，锁就释放了嘛）
表的引擎需要支持事务，比如INNODB。



加表锁：
The correct way to use LOCK TABLES with transactional tables, such as InnoDB tables, is to begin a transaction 
with SET autocommit = 0(not START TRANSACTION) followed by LOCK TABLES, and to not call UNLOCK TABLES until 
you commit the transaction explicitly. 
如下：
SET autocommit=0;
LOCK TABLES t1 WRITE, t2 READ, ...;
... do something with tables t1 and t2 here ...
COMMIT;
UNLOCK TABLES;

加表锁语句：
LOCK TABLES ... WRITE 表写锁
LOCK TABLES ... READ  表读锁




-----------------------------------------------------------------------------------------------------
相关参数
innodb_lock_wait_timeout

---------------------------------------------------------------------------------------------------------
mysql index condition pushdow


MySQL Fabric



GTID

