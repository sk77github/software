按粒度区分的三个策略，粒度从粗到细是按库、按表、按行。
这三个的对比中，并行度越来越大，额外损耗也是。无关大事务不会影响并发度。
 
按照commit_id 的两个策略，适用范围更广，额外消耗也低。
5.7的改进策略并发性更优。但出现大事务会拖后腿。
 
另外，很重要的一点，5.7的策略目的是“模拟主库并发”，所以对于主库单线程更新是无加速作用的。而基于冲突的前三个策略，若满足并发条件，会出现备库比主库执行速度快的情况。这种需求在搭备库或者延迟复制的场景中可能触发。
 
实际上策略的选择取决于应用场景，这是架构师的工作之一。
 
PS：具体5.7的实现原理可参考我们团队的@印风 同学的博客  http://mysqllover.com/?p=1370 (最后一个例子的case也从此摘录）
